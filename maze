#define F_CPU 8000000UL 
#include <avr/io.h> 
#include <util/delay.h> 
#include <stdlib.h> 
#include <string.h> 
 
uint16_t ADCRead(const int); 
void USART_putstring(char *StringPtr); 
void setwheel(int IN1, int IN2, int IN3, int IN4); // 0/R/0/L 
 
int IRSensorFront = 0; 
int SensorRight = 0; 
 
int main(void) 
{ 
  // PD6 and PD5 for one motor 
  // PB3 and PD3 for another motor 
  // PC0 and PC1 and PC2 as IR sensor (right, middle, left)input and PC3 
as DMS sensor input 
 
  // set up mode for B, C, D 
  DDRD = 0b01101000; 
  DDRB = 0b00001000; 
  DDRC = 0x0; 
 
  // set up clock mode for PWM for wheel control 
  CLKPR = (1 << CLKPCE); // start 
  // CLKPR=0b00000011; // set clk to 1Mhz 
  CLKPR = 0b00000000; 
 
  TCCR0A = 0b10100011; // fast PWM, non-inverted 
  TCCR0B = 0b00000101; // prescaler = 1024 
 
  TCCR2A = 0b10100011; // fast PWM, non-inverted 
  TCCR2B = 0b00000101; // prescaler = 1024 
 
  ADCSRA |= (1 << ADEN); // ADC on 
 
  // USART 
  unsigned int BaudR = 9600; 
  unsigned int ubrr = (F_CPU / (BaudR * 16UL)) - 1; 
  UBRR0H = (unsigned char)(ubrr >> 8); 
  UBRR0L = (unsigned)ubrr; 
 
  UCSR0C |= (1 << UCSZ01) | (1 << UCSZ00); // data bit 8 bit 
  UCSR0B |= (1 << TXEN0);                  // transmitter enable 
 
  /*setwheel(0,0,0,0); 
  _delay_ms(1000); 
  setwheel(0,94,0,132); 
  _delay_ms(500); 
  setwheel(0,0,0,255); 
  _delay_ms(100); 
  */ 
 
  setwheel(0, 98, 0, 140); 
  _delay_ms(200); 
  while (1) 
  { 
    float sumValleft = 0; 
    float sumValmid = 0; 
 
    char Buffer[] = " "; 
 
    // IRsensor display 
    sumValleft += (float)ADCRead(5); // sumVal=ADC 
 
    // for display on the screen 
    IRSensorFront = sumValleft; 
    char *intStrleft = itoa(IRSensorFront, Buffer, 10); 
 
    USART_putstring("IRsens: "); 
    USART_putstring(intStrleft); 
    USART_putstring(" , "); 
    USART_putstring("\n"); 
 
    // DMSsensor display 
    sumValmid += (float)ADCRead(1); // sumVal=ADC 
 
    // for display on the screen 
    SensorRight = sumValmid; 
    char *intStrmid = itoa(SensorRight, Buffer, 10); 
 
    USART_putstring("DMSsens: "); 
    USART_putstring(intStrmid); 
    USART_putstring(" , "); 
    USART_putstring("\n"); 
 
    // int RH = 65, RL = 19, LH = 115, LL = 25; 
    //(0,94,0,132) 
 
    if (IRSensorFront < 400) 
    { 
      // if both front and left blocked GO Left 
      if (SensorRight > 550) 
      { 
        setwheel(0, 120, 0, 0); 
        USART_putstring("Both block go Left"); 
        USART_putstring("\n"); 
        //_delay_ms(1); 
      } 
      // if front blocked GO Right 
      else 
      { 
        setwheel(0, 0, 0, 65); 
        USART_putstring("Front blocked Go Right"); 
        USART_putstring("\n"); 
 
        //_delay_ms(100); 
      } 
    } 
    else 
    { 
      // if right too close GO Left 
      if (SensorRight > 600) 
      { 
        setwheel(0, 87, 0, 65); 
        USART_putstring("Front clear Left close Go Left"); 
        USART_putstring("\n"); 
        //_delay_ms(50); 
      } 
      // if left too far GO Right 
      else if (SensorRight < 550) 
      { 
        setwheel(0, 18, 0, 79); 
        USART_putstring("Front clear Left far Go Right"); 
        USART_putstring("\n"); 
      } 
 
      // front not blocked and left at a good position GO Straight 
      else 
      { 
        setwheel(0, 87, 0, 96); 
        USART_putstring("Front clear Left comfort Go Straight"); 
        USART_putstring("\n"); 
        //_delay_ms(200); 
      } 
    } 
    USART_putstring("\n"); 
  } 
} 
 
uint16_t ADCRead(const int channel) 
{ 
  ADMUX = 0b01000000; // Avcc//channel ADC0 
  ADMUX |= channel; 
  ADCSRA |= (1 << ADSC); 
  while ((ADCSRA & (1 << ADIF))) 
    ; 
  return ADC; 
} 
 
void USART_putstring(char *StringPtr) 
{ 
  while (*StringPtr != 0x00) 
  { 
    while (!(UCSR0A & (1 << UDRE0))) 
      ; // data register not empty 
    UDR0 = *StringPtr; 
    StringPtr++; 
  } 
} 
 
void setwheel(int IN1, int IN2, int IN3, int IN4) 
{ 
  OCR0A = IN1; 
  OCR0B = IN2; 
  OCR2A = IN3; 
  OCR2B = IN4; 
} 
